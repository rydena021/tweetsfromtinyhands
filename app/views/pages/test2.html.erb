<div class='container-fluid'>

  <div class='row'>
    <div class='col s6' id='dc-hour-chart'>
      <h4>Tweets by Hour</h4>
    </div>
    <div class='col s6' id='dc-device-chart'>
      <h4>Tweets by Device</h4>
    </div>
  </div>

  <div class='row'>
    <div class='col s12' id='dc-date-chart'>
      <h4>Tweet Timeline</h4>
    </div>
  </div>



  <div class='row'>
    <div class='col s12'>
      <table class='table highlight' id='dc-table-graph'>
        <thead>
          <tr class='header'>
            <th>Date</th>
            <th>Time</th>
            <th>Tweet</th>
            <th>Device</th>
          </tr>
        </thead>
      </table>
    </div>
  </div>
</div>



<script>

// Load tweets from JSON
d3.json("<%= asset_path 'tweets.json' %>", function(error, tweets) {

  // TODO: rewrite functions below for cleaner, accurate data assignment.

  // Shitty string cleaner to remove URLs.
  function cleanTweet(tweet) {
      switch(true) {
          case /https:\/\/t.co+\S+/i.test(tweet):
            return tweet.replace(/https:\/\/t.co+\S+/gi,'');
            break;
          default:
            return tweet;
            break;
      }
  };

  // Returns array of lexical data.
  function tweetMetrics(tweet) {

      var metrics = { "words": 0, "chars": 0, "caps": 0, "exclams": 0 };

      if (tweet.trim().split(/\s+\b/)) {
        metrics.words = tweet.trim().split(/\s+\b/).length;
      }
      if (tweet.match(/\w/g)) {
        metrics.chars = tweet.match(/\w/g).length;
      }
      if (tweet.match(/[A-Z]/g)) {
        metrics.caps = tweet.match(/[A-Z]/g).length;
      }
      if (tweet.match(/!/g)) {
        metrics.exclams = tweet.match(/!/g).length;
      }
      return metrics;
  };

  // Regexs for device assignment.
  function getDevice(tweet) {
      switch (true) {
          case /Twitter for Android/i.test(tweet):
            return "Android";
            break;
          case /Twitter for iPhone/i.test(tweet):
            return "iPhone";
            break;
          case /Twitter for iPad/i.test(tweet):
            return "iPad";
            break;
          case /Instagram/i.test(tweet):
            return "Instagram";
            break;
          case /Periscope/i.test(tweet):
            return "Periscope";
            break;
          case /Twitter Web Client/i.test(tweet):
            return "Web Client";
            break;
          case /Media Studio/i.test(tweet):
            return "Media Studio";
            break;
          case /Twitter Ads/i.test(tweet):
            return "Ad";
            break;
          default:
            return "Unknown";
            break;
      }
  };

  // Various formatters.
  var formatTime = d3.time.format("%I:%M %p"),
      formatHour = d3.time.format("%H"),
      formatDate = d3.time.format("%a %b %d %X %Z %Y");
      formatTableDate = d3.time.format("%x"),

  tweets.forEach(function(d, i) {
    d.index = +i;
    d.id = +d.id;
    d.retweet_count = +d.retweet_count;
    d.favorite_count = +d.favorite_count;
    d.text = cleanTweet(d.text);
    d.metrics = tweetMetrics(d.text);
    d.device = getDevice(d.source);
    d.date = formatDate.parse(d.created_at);
  });

  // Create the dc.js chart objects & link to div
  var dataTable = dc.dataTable("#dc-table-graph"),
      hourChart = dc.barChart("#dc-hour-chart"),
      dateChart = dc.barChart("#dc-date-chart"),
      deviceChart = dc.pieChart("#dc-device-chart");


    // Run the data through crossfilter and load our 'facts'
  var facts = crossfilter(tweets);

  // Create dataTable dimension
  var hourDimension = facts.dimension(function (d) { return formatHour(d.date); }),
      hourValueGroupCount = hourDimension.group().reduceCount(function(d) { return formatHour(d.date); }), // counts

      deviceDimension = facts.dimension(function(d) {return d.device; }),
      deviceValueGroupCount = deviceDimension.group().reduceCount(function(d) { return formatHour(d.device); });

      dateDimension = facts.dimension(function(d) {return d.date; }),
      dateValueGroupCount = dateDimension.group().reduceCount(function(d) { return d.date; });

  // Setup the charts
  hourChart.width(600)
    .height(400)
    .margins({top: 10, right: 10, bottom: 20, left: 40}) .dimension(hourDimension)
    .group(hourValueGroupCount)
    .round(d3.time.day.round)
    .transitionDuration(500)
    .x(d3.scale.linear().domain([0, 24])) .elasticY(true)
    .xAxis().tickFormat();

  deviceChart
      .width(250)
      .height(250)
      .dimension(deviceDimension)
      .group(deviceValueGroupCount)
      .innerRadius(20);

  // Setup the charts
  dateChart.width(960)
    .height(300)
    .margins({top: 10, right: 10, bottom: 20, left: 40}) .dimension(dateDimension)
    .group(dateValueGroupCount)
    .transitionDuration(500)
    .centerBar(true)
    .x(d3.scale.ordinal().domain([new Date(2015, 5, 1), new Date(2017, 5, 1)])) .elasticY(true)
    .filter([new Date(2017, 0, 1), new Date(2017, 3, 1)])
    .xAxis().tickFormat();

  // Table of earthquake data
  dataTable.width(960).height(800)
    .dimension(dateDimension)
    .group(function(d) { return "dc.js insists on putting a row here so I remove it using JS"
     })
    .size(50)
    .columns([
      function(d) { return formatTableDate(d.date); },
      function(d) { return formatTime(d.date); },
      function(d) { return d.text; },
      function(d) { return d.device; }
    ])
    .sortBy(function(d){ return d.date; })
    .order(d3.descending)
    .on('renderlet', function (table) {
      // each time table is rendered remove nasty extra row dc.js insists on adding
      table.select('tr.dc-table-group').remove();
    });
  // Render the Charts
  dc.renderAll();

});

  </script>
